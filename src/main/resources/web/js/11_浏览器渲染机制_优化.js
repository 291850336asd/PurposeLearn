/**
 * 客户端浏览器从服务器获取到需要渲染的页面代码后
 * 开辟一个GUI渲染线程自上而下的解析代码，最后绘制出对应的页面
 *
 * 自上而下的渲染解析代码过程是‘同步’的，但是有些操作是异步的
 * 1.关于css资源的加载
 *   + 遇到的是<style> '内嵌样式'  ‘同步’交给GUI渲染线程解析
 *   + 遇到<link> '外链样式'  ‘异步’开辟一个新的HTTP网络请求线程,不等待资源请求返回，GUI线程继续向下渲染
 *       等GUI线程处理完后，再基于HTTP网路请求线程返回的文件进行解析渲染
 *       注意：同一个源下，根据不同浏览器最多只允许开辟4-7个HTTP线程
 *   + 遇到@import ‘导入式样式’ 开辟HTTP网络线程‘同步’请求资源文件，再资源文件没有返回之前，GUI线程会被堵塞
 * 2.遇到<script>资源的请求
 *   + 默认都是‘同步’的，需要开辟HTTP网络线程请求回来后并且交给JS渲染线程解析完后，GUI线程才能继续执行，所以<script>也是堵塞GUI线程的
 *   + async属性：遇到<script  async>首先也是开辟一个HTTP网络线程去加载资源，
 *       但是GUI渲染线程继续执行，但是一旦资源返回会中断GUI线程，先把请求回来的JS进行渲染解析
 *   + defer属性：遇到<script  defer>首先也是开辟一个HTTP网络线程去加载资源，
 *       并且GUI渲染线程继续执行，GUI线程完成之后，再去处理返回的JS资源 和<link>类似
 * 3.遇到<img>或者音视频资源
 *   + 遇到这些资源也会发送HTTP网路线程加载对应的资源文件，不会阻碍GUI渲染，当GUI渲染完成后才会把请求的资源信息进行解析
 *
 *  Webkit浏览器预测解析：chrome的预加载扫描器html-preload-scanner通过扫描节点中的 “src” , “link”等属性，
 *  找到外部连接资源后进行预加载，避免了资源加载的等待时间，同样实现了提前加载以及加载和执行分离。
 *
 *
 *  页面渲染器的步骤：
 *  1.生成DOM树：自上而下渲染页面，整理好整个页面的DOM结构
 *  2.生成CSSOM树（样式树）：当所有的样式资源请求加载完毕后，按照引入CSS的顺序，依次渲染样式代码，形成样式树
 *  3.Render-Tree渲染树：把生成的DOM树和CSSOM树合并在一起  设置display:none 隐藏的节点不生成渲染树
 *  如果某个资源加载特别慢，浏览器会跳过该资源进行加载
 *  4.Layout 布局/回流/重绘： 根据生成的渲染树，计算它们在设备视口（viewport）内的确定位置和大小
 *       + 回流即layout位置和大小发生变化或者视口大小发生变化
 *  5.分层处理：按照层级定位分层处理，每一个层级都会有详细的绘制步骤
 *  6.Painting: 按照每一个层级计算处理的绘制步骤，开始绘制页面
 *
 *
 *  前段性能优化：CRP(关键渲染路径)
 *  1.生成DOM树  层级不要太深减少dom的层级嵌套，不要使用非标准标签
 *  2.生成CSSOM样式树
 *     + 尽可能不用@import
 *     + 如果css代码比较少，尽可能使用style内嵌样式（尤其是移动端开发）
 *     + 如果使用link尽可能把所有样式资源写到一个文件并且压缩，会减少HTTP请求以及渲染CSS时也不需要再计算依赖关系，而且HTTP并发数有限制
 *     + CSS选择器链短一些，因为CSS选择器渲染是从右到左的  例如 .nar a{} 的性能没有a{}性能好
 *     + 把link等导入操作放到HEAD中（css预先加载），目的是一加载页面就开始请求资源同时GUI去生成DOM树
 *     + ...
 *  3.其它资源
 *     + 对于script来说，尽可能放置到页面底部，防止其堵塞GUI渲染，对于部分<script>需要使用async或defer
 *            async是不管js的依赖关系的，谁先返回就先渲染执行
 *            defer和link一样是等待所有<script defer>资源都请求回来之后按照依赖关系或者导入顺序，依次渲染执行
 *            一般跟业务相关的使用defer,日志统计之类的使用async
 *     + 对于<img>资源
 *          + 懒加载：第一次加载页面是不加载图片，哪怕他是异步的，但是也会占据HTTP请求数据，导致其他资源延后加载
 *          + 图片的BASE64：不用去加载图片，BASE64码基本上代码图片，而且页面的选软速度也会很快
 *             （慎用代码多，但是在webpack这种工程化中可以使用，因为它基于file-loader打包编译可以自动生成BASE64）
 *     + Layout 布局/回流/重绘  重要的优化手段减少DOM的回流和重绘
 *          + 第一次加载页面必然会有一次回流和重绘
 *          + 触发回流后也必然触发重绘，如果只单纯的重绘则不会引发回流，所有优化点在回流上，重绘一般不可避免
 *          + 样式‘分离读写’，把修改样式和或者样式分离开
 *          + 样式集中改变，统一修改
 *          + 缓存布局信息
 *          + 放弃传统的操作DOM，使用vue/react操作数据影响视图
 *          + 批量增加或修改元素  拼接字符串或者文档碎片createDocumentFragment
 *          + 动画等频繁样式改变的操作，运用到postion:fixed/absolute...的元素上（脱离文档流：单独一层）
 *          + CSS3硬件加速（CPU加速），修改元素的transform/opacity(filters)...不会引发DOM的回流，
 *                存在性能消耗会占据大量内存，有时候会导致字体模糊
 *          + 牺牲平滑度换速度
 *          + 避免使用table布局和使用css的js表达式
 *
 *
 *
 * 操作DOM消耗性能：主要是因为DOM回流导致的
 *   + 元素在视口中的位置或大小发生变化，或者元素的删除或新增以及display控制显示隐藏
 *   + 浏览器视口大小发生变化
 *   + 。。。
 * 这些操作都会需要浏览器重新计算每一个元素的位置和大小也就是重新layout也叫reflow
 */

/***
 * 当代浏览器的渲染队列机制：在当前上下文操作中，遇到一行修改样式的代码并没有立即通知浏览器渲染，而是把其放置到渲染队列中，
 * 接下来看还有没有修改样式的代码，如果有则添加到渲染队列中，一直到没有修改样式的代码或者遇到一行获取样式的操作都会刷新浏览器渲染队列把现在队列中的操作统一通知浏览器渲染
 * 这样只会引发一次回流
 *
 * 回流示例
 * box.style.width = "100px";
 * box.style.height = "100px";
 * box.offsetHeight;//box.style.xxx或者window.getComputedStyle(box).xxx 或者 box.clientWidth或者box.scrollWidth等都会刷新队列
 * box.style.position = "absolute";
 * box.style.top = "100px";
 * 以上代码触发两次回流
 *
 *
 * box.style.width = "100px";
 * box.style.height = "100px";
 * box.style.position = "absolute";
 * box.style.top = "100px";
 * box.offsetHeight;//box.style.xxx或者window.getComputedStyle(box).xxx 或者 box.clientWidth或者box.scrollWidth等都会刷新队列
 * 以上代码触发一次回流
 *
 */
