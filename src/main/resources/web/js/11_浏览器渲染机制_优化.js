/**
 * 客户端浏览器从服务器获取到需要渲染的页面代码后
 * 开辟一个GUI渲染线程自上而下的解析代码，最后绘制出对应的页面
 *
 * 自上而下的渲染解析代码过程是‘同步’的，但是有些操作是异步的
 * 1.关于css资源的加载
 *   + 遇到的是<style> '内嵌样式'  ‘同步’交给GUI渲染线程解析
 *   + 遇到<link> '外链样式'  ‘异步’开辟一个新的HTTP网络请求线程,不等待资源请求返回，GUI线程继续向下渲染
 *       等GUI线程处理完后，再基于HTTP网路请求线程返回的文件进行解析渲染
 *       注意：同一个源下，根据不同浏览器最多只允许开辟4-7个HTTP线程
 *   + 遇到@import ‘导入式样式’ 开辟HTTP网络线程‘同步’请求资源文件，再资源文件没有返回之前，GUI线程会被堵塞
 * 2.遇到<script>资源的请求
 *   + 默认都是‘同步’的，需要开辟HTTP网络线程请求回来后并且交给JS渲染线程解析完后，GUI线程才能继续执行，所以<script>也是堵塞GUI线程的
 *   + async属性：遇到<script  async>首先也是开辟一个HTTP网络线程去加载资源，
 *       但是GUI渲染线程继续执行，但是一旦资源返回会中断GUI线程，先把请求回来的JS进行渲染解析
 *   + defer属性：遇到<script  defer>首先也是开辟一个HTTP网络线程去加载资源，
 *       并且GUI渲染线程继续执行，GUI线程完成之后，再去处理返回的JS资源 和<link>类似
 * 3.遇到<img>或者音视频资源
 *   + 遇到这些资源也会发送HTTP网路线程加载对应的资源文件，不会阻碍GUI渲染，当GUI渲染完成后才会把请求的资源信息进行解析
 *
 *  Webkit浏览器预测解析：chrome的预加载扫描器html-preload-scanner通过扫描节点中的 “src” , “link”等属性，
 *  找到外部连接资源后进行预加载，避免了资源加载的等待时间，同样实现了提前加载以及加载和执行分离。
 *
 *
 *  页面渲染器的步骤：
 *  1.生成DOM树：自上而下渲染页面，整理好整个页面的DOM结构
 *  2.生成CSSOM树（样式树）：当所有的样式资源请求加载完毕后，按照引入CSS的顺序，依次渲染样式代码，形成样式树
 *  3.Render-Tree渲染树：把生成的DOM树和CSSOM树合并在一起  设置display:none 隐藏的节点不生成渲染树
 *
 */