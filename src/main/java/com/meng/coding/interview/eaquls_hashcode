1.Java对于equals()方法和hashCode()方法的规定

如果两个对象equals()方法相等则它们的hashCode返回值一定要相同，如果两个对象的hashCode返回值相同，但它们的equals()方法不一定相等。

两个对象的hashCode()返回值相等不能判断这两个对象是相等的，但两个对象的hashcode()返回值不相等则可以判定两个对象一定不相等。

2.hashCode()返回值和 == 的关系

若 == 返回true，则两边的对象的hashCode()返回值必须相等，若 == 返回false，则两边对象的hashCode()返回值可能相等，也可能不等
，因为Java中对象默认的equals()方法就是用==实现的。而Java对于equals方法和hashCode方法的规定是如果两个对象equals()方法相等，
则hashCode值一定会相同，如果两个对象的hashCode值相同，则它们的equals()方法不一定相等。

3.Java中的hashCode()的作用

hashCode()的作用是为了提高在散列结构存储中查找的效率，在线性表中没有作用；只有每个对象的 hash 码尽可能不同才能保证散列的存取性能，
事实上 Object 类提供的默认实现确实保证每个对象的 hash 码不同（在对象的内存地址基础上经过特定算法返回一个 hash 码）。
在 Java 有些集合类（HashSet）中要想保证元素不重复可以在每增加一个元素就通过对象的 equals 方法比较一次，那么当元素很多时后添加到集合中的元素比较的次数就非常多了，
也就是说如果集合中现在已经有 3000 个元素则第 3001 个元素加入集合时就要调用 3000 次 equals 方法，这显然会大大降低效率，
于是 Java 采用了哈希表的原理，这样当集合要添加新的元素时会先调用这个元素的 hashCode 方法就一下子能定位到它应该放置的物理位置上（实际可能并不是），
如果这个位置上没有元素则它就可以直接存储在这个位置上而不用再进行任何比较了，如果这个位置上已经有元素了则就调用它的 equals 方法与新元素进行比较，
相同的话就不存，不相同就散列其它的地址，这样一来实际调用 equals 方法的次数就大大降低了，几乎只需要一两次，而 hashCode 的值对于每个对象实例来说是一个固定值。

4.Java中重写equals()方法时尽量要重写hashCode()方法的原因

当 equals 方法被重写时通常有必要重写 hashCode 方法来维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码，
如果不这样做的话就会违反 hashCode 方法的常规约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括 HashMap、HashSet、Hashtable 等。

hashCode 方法的常规约定如下：

程序执行期间只要对象 equals 方法比较操作所用到的信息没有被修改，则对这同一个对象无论调用多次 hashCode 方法都必须返回同一个整数。

如果两个对象根据 equals 方法比较是相等的则调用这两个对象中任意一个对象的 hashCode 方法都必须产生同样的整数结果。

如果两个对象根据 equals 方法比较是不相等的，则调用这两个对象中任意一个对象的 hashCode 方法不一定要产生相同的整数结果
（尽量保证不相等的对象产生截然不同的整数结果是可以提高散列表性能的）。