使用号段的方式来获取自增 ID，号段可以理解成批量获取。比如从数据库获取 ID 时，就可以批量获取多个 ID 并缓存在本地，提升效率。

比如每次从数据库获取 ID 时，就获取一个号段，如 (1,1000]，这个范围表示1000个  ID，业务应用在请求提供 ID 时，只需要在本地从1开始自增并返回，而不需要每次都取请求数据库，一直到本地自增到1000时，也就是当前号段已经用完了，才去数据库重新获取下一号段。

对数据库表进行改动如下：

CREATE TABLE Test (
  id int(10) NOT NULL,
  current_max_id bigint(20) NOT NULL COMMENT '当前最大Id',
  increment_step int(10) NOT NULL COMMENT '号段的长度',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
这个数据表是用来记录自增步长，以及当前自增 ID 的最大值（也就是当前已被申请号段的最后那个值），而自增逻辑就移动到业务里头去实现，所以数据库不需要这部分逻辑。

这种方案不再强依赖数据库，就算数据库不可用，那么系统也能继续支撑一段时间，但如果系统重启，就会丢失一段 ID，导致 ID 空洞。

为提高可用性，需要做一个集群，业务在请求集群获取 ID 时，会随机的选择某个节点进行获取，对每个节点来说，数据库连接的是同个数据库，那么就可能会产生多个节点同时请求数据库获取号段，这时就可以利用乐观锁来进行控制，比如在数据库表中增加一个 version 字段，在获取号段时使用如下 SQL：

update Test set current_max_id = #{newMaxId}, version = version+1 where version = #{version}
以上 newMaxId 是根据 oldMaxId + 步长 算出来的，只要上面的 update 更新成功，也就表示号段获取成功。



优点：
非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。
ID号单调自增，可以实现一些对ID有特殊要求的业务。
缺点：
强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。
ID发号性能瓶颈限制在单台MySQL的读写性能。